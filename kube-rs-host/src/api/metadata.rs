pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::{ListMeta, ObjectMeta};
use k8s_openapi::Metadata;
use serde::{Deserialize, Serialize};

/// An accessor trait for Metadata
///
/// This for a subset of Kubernetes type that do not end in List
/// These types, using ObjectMeta, SHOULD all have required properties:
/// - .metadata
/// - .metadata.name
/// And these optional properties:
/// - .metadata.namespace
/// - .metadata.resource_version
///
/// This avoids a bunch of the unnecessary unwrap mechanics for apps
pub trait Meta: Metadata {
    /// Metadata that all persisted resources must have
    fn meta(&self) -> &ObjectMeta;
    /// The name of the resource
    fn name(&self) -> String;
    /// The namespace the resource is in
    fn namespace(&self) -> Option<String>;
    /// Tthe resource version
    fn resource_ver(&self) -> Option<String>;
}

/// Implement accessor trait for any ObjectMeta-using Kubernetes Resource
impl<K> Meta for K
where
    K: Metadata<Ty = ObjectMeta>,
{
    fn meta(&self) -> &ObjectMeta {
        self.metadata()
    }

    fn name(&self) -> String {
        self.meta().name.clone().expect("kind has metadata.name")
    }

    fn resource_ver(&self) -> Option<String> {
        self.meta().resource_version.clone()
    }

    fn namespace(&self) -> Option<String> {
        self.meta().namespace.clone()
    }
}

/// A convenience struct for ad-hoc serialization
///
/// Mostly useful for `Object`
#[derive(Deserialize, Serialize, Clone, Default)]
#[serde(rename_all = "camelCase")]
pub struct TypeMeta {
    /// The version of the API
    pub api_version: String,

    /// The name of the API
    pub kind: String,
}
